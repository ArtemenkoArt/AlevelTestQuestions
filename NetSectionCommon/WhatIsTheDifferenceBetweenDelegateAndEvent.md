# What is the difference between Delegate and Event? 
# Различия между делегатами и событиями

Разработчики, не имеющие опыта работы с платформой .NET Core, часто не могут решить, что следует выбрать: структуру на основе delegates или на основе events. Это сложный вопрос, так как эти две возможности языка очень похожи. Более того, события основаны на тех же средствах языка, которые обеспечивают поддержку делегатов.
И те и другие обеспечивают сценарии позднего связывания, в которых взаимодействие компонента осуществляется путем вызова метода, известного только во время выполнения. И те и другие поддерживают методы с одним или несколькими подписчиками. Иногда это называют поддержкой одноадресности и многоадресности. Синтаксис добавления и удаления обработчиков в обоих случаях похож. Наконец, при вызове событий и делегатов используется абсолютно одинаковый синтаксис вызова методов. Более того, поддерживается одинаковый синтаксис метода Invoke() для использования с оператором ?..
Учитывая такое сходство, легко могут возникнуть проблемы с выбором подходящего механизма в той или иной ситуации.

## Прослушивание событий необязательно

Самым важным фактором при выборе подходящего механизма является обязательность наличия подключенного подписчика. Если ваш код должен вызывать код, предоставленный подписчиком, следует использовать структуру на основе делегатов. Если код может выполнить все задачи, не вызывая подписчики, следует использовать структуру на основе событий.
Обратите внимание на примеры, рассматривавшиеся в этом разделе. Код, который вы создавали с помощью List.Sort(), должен содержать функцию сравнения для правильной сортировки элементов. Запросам LINQ необходимо предоставить делегаты для определения элементов, которые следует вернуть. В обоих случаях использовалась структура на основе делегатов.
Рассмотрим событие Progress. Оно сообщает о ходе выполнения задачи. Задача продолжает выполняться вне зависимости от того, есть ли прослушиватели. Еще один пример — FileSearcher. Нахождение всех искомых файлов производится, даже если не подключены обработчики событий. Элементы управления UX продолжают работать правильно, даже если нет подписчиков, прослушивающих события. В обоих примерах используются структуры на основе событий.

## Для возвращаемых значений требуются делегаты

Еще одним аспектом является прототип метода, который требуется для метода делегата. Как вы уже видели, все делегаты, используемые для событий, имеют тип возвращаемого значения void. Вы уже также знаете, что есть идиомы для создания обработчиков событий, которые передают информацию обратно источникам событий, изменяя свойства объекта аргумента события. Хотя такие идиомы работают, они не так естественны, как возвращение значения из метода.
Обратите внимание на то, что часто используются оба этих эвристических метода: если метод делегата возвращает значение, то оно, скорее всего, будет каким-либо образом влиять на алгоритм.

## Прослушиватели событий часто имеют более длительный срок существования

Это не столь важный фактор. Однако структура на основе событий может оказаться более естественной, когда источник событий инициирует события в течение длительного периода времени. Примерами могут служить элементы управления UX во многих системах. После подписания на событие источник события может вызывать события в течение всего времени существования программы. (Когда события больше не нужны, вы можете отменить подписку на них.)
Сравните это с часто встречающимися структурами на основе делегатов, когда делегат применяется в качестве аргумента метода и не используется после того, как метод возвращает управление.

## Тщательно оценивайте ситуацию

Приведенные выше указания не являются строгими правилами. Они представляют собой лишь рекомендации, которые могут помочь вам выбрать правильный вариант в конкретном случае. Так как эти механизмы схожи, вы можете смоделировать и тот и другой, чтобы проверить, какой из них окажется естественнее. Оба они хорошо подходят для сценариев с поздним связыванием. Используйте тот механизм, который лучше соответствует вашим требованиям.


Чтобы понять различия, вы можете посмотреть на это 2 примера

Пример с делегатами (в данном случае Action - это своего рода делегат, который не возвращает значение)
```csharp
public class Animal
{
    public Action Run {get; set;}

    public void RaiseEvent()
    {
        if (Run != null)
        {
            Run();
        }
    }
}
```
Чтобы использовать делегат, вы должны сделать что-то вроде этого:
```csharp
Animal animal= new Animal();
animal.Run += () => Console.WriteLine("I'm running");
animal.Run += () => Console.WriteLine("I'm still running") ;
animal.RaiseEvent();
```
Этот код работает хорошо, но у вас могут быть слабые места.

Например, если я пишу это:
```csharp
animal.Run += () => Console.WriteLine("I'm running");
animal.Run += () => Console.WriteLine("I'm still running");
animal.Run = () => Console.WriteLine("I'm sleeping") ;
```
с последней строкой кода, я переопределил предыдущие действия только с одним отсутствующим + (я использовал = вместо +=)

Другим слабым местом является то, что каждый класс, который использует ваш класс Animal, может поднять RaiseEvent, просто называя его animal.RaiseEvent().

Чтобы избежать этих слабых мест, вы можете использовать events в С#.

Ваш класс Animal изменится следующим образом:
```csharp
public class ArgsSpecial : EventArgs
{
    public ArgsSpecial (string val)
    {
        Operation=val;
    }

    public string Operation {get; set;}
} 

public class Animal
{
    // Empty delegate. In this way you are sure that value is always != null 
    // because no one outside of the class can change it.
    public event EventHandler<ArgsSpecial> Run = delegate{} 

    public void RaiseEvent()
    {  
         Run(this, new ArgsSpecial("Run faster"));
    }
}
```
для вызова событий
```csharp
 Animal animal= new Animal();
 animal.Run += (sender, e) => Console.WriteLine("I'm running. My value is {0}", e.Operation);
 animal.RaiseEvent();
 ```
Отличия:

Вы не используете общедоступное свойство, а общедоступное поле (используя события, компилятор защищает ваши поля от нежелательного доступа).
События не могут быть назначены напрямую. В этом случае это не приведет к предыдущей ошибке, которую я показал с переопределением поведения.
Никто из вашего класса не может поднять это событие.
События могут быть включены в декларацию интерфейса, тогда как поле не может
Примечания:

EventHandler объявляется следующим делегатом:

public delegate void EventHandler (object sender, EventArgs e)
требуется отправитель (типа объекта) и аргументы событий. Отправитель имеет значение null, если он исходит из статических методов.

Этот пример, который использует EventHandler<ArgsSpecial>, также можно записать с помощью EventHandler.